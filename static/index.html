<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Shuttle Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Minimal inline fallback styling to ensure layout looks OK if styles.css missing */
    body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #map { height: 100vh; width: 100%; }
    #hud { position: absolute; z-index: 1000; top: 12px; left: 12px; background: rgba(255,255,255,0.95); padding: 8px 12px; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.08); }
    #status { font-size: 13px; color: #333; display: inline-block; vertical-align: middle; }
    #follow-btn { margin-left: 12px; background: white; border: 1px solid rgba(0,0,0,0.08); padding: 6px 10px; font-size: 14px; border-radius: 6px; cursor: pointer; }
    #follow-btn:disabled { opacity: 0.6; cursor: default; }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- small HUD -->
  <div id="hud" aria-hidden="false">
    <span id="status">Loading route...</span>
  </div>

<script>
  // -- polling configuration --
  const VEHICLE_POLL_INTERVAL_MS = 8000;
  const VEHICLE_ANIMATION_DURATION_MS = VEHICLE_POLL_INTERVAL_MS * 0.9;

  // -- backend API endpoints --
  const ROUTE_API_URL = "/api/route";
  const VEHICLES_API_URL = "/api/vehicles";

  const statusElement = document.getElementById("status");

  // -- map initialization --
  const map = L.map("map").setView([42.377, -71.12], 14);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

  // -- route layers --
  let routePolylineLayer = null;
  const routeStopsLayer = L.layerGroup().addTo(map);

  // -- vehicle marker registry --
  // maps vehicle_id -> { marker, lastLatLng, animationHandle }
  const markersByVehicleId = {};

  // -- follow shuttle state (declare early) --
  let followMode = false;
  let followedVehicleId = null;
  let followUserLatLng = null;

  // store last vehicles payload (useful for nearest lookup if markers not yet created)
  let lastVehicles = [];

  // -- active route color (comes from backend) --
  let activeRouteColor = "#1E90FF";

  // -- helper: format unix timestamp (seconds) into readable time --
  function formatEpochSeconds(epochSeconds) {
    if (!epochSeconds) return "";
    const date = new Date(epochSeconds * 1000);
    return date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  }

  // -- animation helper --
  function animateMarkerTo(vehicleId, fromLatLng, toLatLng, durationMs) {
    const markerEntry = markersByVehicleId[vehicleId];
    if (!markerEntry) return;

    if (markerEntry.animationHandle && markerEntry.animationHandle.raf) {
      cancelAnimationFrame(markerEntry.animationHandle.raf);
    }

    const startTime = performance.now();
    const start = { lat: fromLatLng.lat, lng: fromLatLng.lng };
    const end = { lat: toLatLng.lat, lng: toLatLng.lng };

    function step(now) {
      const progress = Math.min(1, (now - startTime) / durationMs);

      const eased = progress < 0.5
        ? 2 * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;

      const currentLat = start.lat + (end.lat - start.lat) * eased;
      const currentLng = start.lng + (end.lng - start.lng) * eased;

      markerEntry.marker.setLatLng([currentLat, currentLng]);

      if (progress < 1) {
        markerEntry.animationHandle.raf = requestAnimationFrame(step);
      }
    }

    markerEntry.animationHandle = { raf: requestAnimationFrame(step) };
  }

  // -- custom shuttle marker SVG --
  function passioShuttleSVG(bearingDegrees, strokeColor) {
    const bearing = (bearingDegrees ?? 0);
    const stroke = strokeColor || "#1f7a1f";

    return `
      <svg width="56" height="56" viewBox="0 0 56 56" style="overflow: visible;">
        <defs>
          <filter id="shadow" x="-30%" y="-30%" width="160%" height="160%">
            <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="rgba(0,0,0,0.25)"/>
          </filter>
        </defs>

        <g transform="translate(28 28) rotate(${bearing}) translate(-28 -28)">
          <path d="M28 2 L42 22 L28 14 L14 22 Z" fill="${stroke}" filter="url(#shadow)"/>
        </g>

        <g filter="url(#shadow)">
          <path d="M24 44 C26 50, 30 50, 32 44"
                fill="#fff" stroke="${stroke}" stroke-width="2" stroke-linecap="round"/>
          <circle cx="28" cy="28" r="16" fill="#fff" stroke="${stroke}" stroke-width="3"/>
        </g>
      </svg>
    `;
  }

  function buildShuttleIcon(bearingDegrees, strokeColor) {
    return L.divIcon({
      className: "",
      html: passioShuttleSVG(bearingDegrees, strokeColor),
      iconSize: [56, 56],
      iconAnchor: [28, 40],
    });
  }

  // -- follow shuttle UI (create after statusElement exists) --
  const followButton = document.createElement("button");
  followButton.id = "follow-btn";
  followButton.type = "button";
  followButton.textContent = "Follow nearest shuttle";
  followButton.title = "Click to follow the shuttle closest to your current location";
  followButton.style.marginLeft = "12px";

  if (statusElement && statusElement.parentNode) {
    statusElement.parentNode.insertBefore(followButton, statusElement.nextSibling);
  } else {
    document.body.appendChild(followButton);
  }

  // -- helper: haversine distance in meters between two lat/lng pairs --
  function haversineMeters(aLat, aLng, bLat, bLng) {
    const toRad = x => (x * Math.PI) / 180;
    const R = 6371000;
    const dLat = toRad(bLat - aLat);
    const dLng = toRad(bLng - aLng);
    const lat1 = toRad(aLat);
    const lat2 = toRad(bLat);
    const sinDlat = Math.sin(dLat / 2);
    const sinDlng = Math.sin(dLng / 2);
    const a = sinDlat * sinDlat + Math.cos(lat1) * Math.cos(lat2) * sinDlng * sinDlng;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // -- helper: find the vehicle id closest to a lat/lng (returns null if none) --
  function findClosestVehicleId(lat, lng, vehicles) {
    if (!vehicles || vehicles.length === 0) return null;
    let bestId = null;
    let bestDist = Infinity;
    for (const v of vehicles) {
      if (v && v.id != null && v.lat != null && v.lon != null) {
        const d = haversineMeters(lat, lng, v.lat, v.lon);
        if (d < bestDist) {
          bestDist = d;
          bestId = String(v.id);
        }
      }
    }
    return bestId;
  }

  // -- start following a vehicle id (centers map to vehicle immediately) --
  function startFollowing(vid) {
    if (!vid) return false;
    const entry = markersByVehicleId[String(vid)];
    if (!entry) return false;
    followMode = true;
    followedVehicleId = String(vid);
    followButton.textContent = "Stop following";
    if (entry && entry.lastLatLng) {
      map.panTo(entry.lastLatLng, { animate: true, duration: 0.5 });
    }
    return true;
  }

  // -- stop following --
  function stopFollowing() {
    followMode = false;
    followedVehicleId = null;
    followButton.textContent = "Follow nearest shuttle";
  }

  // -- load static route data from backend --
  async function loadActiveRoute() {
    try {
      const response = await fetch(ROUTE_API_URL, { cache: "no-store" });
      const routePayload = await response.json();
      if (routePayload.error) throw new Error(routePayload.error);

      activeRouteColor = routePayload.route_color || activeRouteColor;

      if (routePolylineLayer) {
        map.removeLayer(routePolylineLayer);
        routePolylineLayer = null;
      }
      routeStopsLayer.clearLayers();

      const shapeCoordinates = routePayload?.route_geojson?.features?.[0]?.geometry?.coordinates || [];
      if (shapeCoordinates.length > 0) {
        const latLngs = shapeCoordinates.map(coord => [coord[1], coord[0]]);
        routePolylineLayer = L.polyline(latLngs, { weight: 5, color: activeRouteColor }).addTo(map);
        map.fitBounds(routePolylineLayer.getBounds().pad(0.2));
      }

      (routePayload.stops || []).forEach(stop => {
        L.circleMarker([stop.lat, stop.lon], {
          radius: 6,
          color: activeRouteColor,
          weight: 2,
          fillColor: activeRouteColor,
          fillOpacity: 0.85
        })
        .bindPopup(stop.name)
        .addTo(routeStopsLayer);
      });

      statusElement.textContent = `Route loaded • ${routePayload.route_name || ""}`;
    } catch (error) {
      console.error("Failed to load route:", error);
      statusElement.textContent = "Error loading route (see console)";
    }
  }

  // -- realtime vehicle polling --
  async function refreshVehicles() {
    try {
      const response = await fetch(VEHICLES_API_URL, { cache: "no-store" });
      const vehiclesPayload = await response.json();
      if (vehiclesPayload.error) throw new Error(vehiclesPayload.error);

      const vehicles = vehiclesPayload.vehicles || [];
      lastVehicles = vehicles; // keep for nearest lookup fallback
      statusElement.textContent = `Active shuttles: ${vehicles.length} • updated ${new Date().toLocaleTimeString()}`;

      const seenVehicleIds = new Set();

      vehicles.forEach(vehicle => {
        const vehicleId = String(vehicle.id);
        seenVehicleIds.add(vehicleId);

        const nextLatLng = L.latLng(vehicle.lat, vehicle.lon);

        const popupHtml =
          `<b>Vehicle ${vehicleId}</b><br/>` +
          (vehicle.label ? `Label: ${vehicle.label}<br/>` : "") +
          (vehicle.trip_id ? `Trip: ${vehicle.trip_id}<br/>` : "") +
          (vehicle.stop_name ? `Stop: ${vehicle.stop_name}<br/>` : "") +
          (vehicle.timestamp ? `Timestamp: ${formatEpochSeconds(vehicle.timestamp)}<br/>` : "");

        if (!markersByVehicleId[vehicleId]) {
          const marker = L.marker(nextLatLng, {
            icon: buildShuttleIcon(vehicle.bearing, activeRouteColor)
          }).addTo(map);

          marker.bindPopup(popupHtml);

          markersByVehicleId[vehicleId] = {
            marker,
            lastLatLng: nextLatLng,
            animationHandle: null
          };
        } else {
          const existing = markersByVehicleId[vehicleId];

          existing.marker.setIcon(buildShuttleIcon(vehicle.bearing, activeRouteColor));
          existing.marker.setPopupContent(popupHtml);

          animateMarkerTo(vehicleId, existing.lastLatLng, nextLatLng, VEHICLE_ANIMATION_DURATION_MS);

          existing.lastLatLng = nextLatLng;

          // If we are following this vehicle, pan the map to keep it in view
          if (followMode && followedVehicleId === vehicleId) {
            map.panTo(nextLatLng, { animate: true, duration: 0.25 });
          }
        }
      });

      // remove markers that disappeared from feed
      Object.keys(markersByVehicleId).forEach(vehicleId => {
        if (!seenVehicleIds.has(vehicleId)) {
          map.removeLayer(markersByVehicleId[vehicleId].marker);
          delete markersByVehicleId[vehicleId];
        }
      });

      // If followed vehicle is gone from feed, stop following
      if (followMode && followedVehicleId && !seenVehicleIds.has(followedVehicleId)) {
        stopFollowing();
        statusElement.textContent = "Followed shuttle disappeared; stopped following.";
      }

    } catch (error) {
      console.error("Failed to refresh vehicles:", error);
      statusElement.textContent = "Error fetching vehicles (see console)";
    }
  }

  // -- follow button click handler --
  followButton.addEventListener("click", () => {
    if (followMode) {
      stopFollowing();
      return;
    }

    if (!navigator.geolocation) {
      alert("Geolocation not supported by your browser.");
      return;
    }

    followButton.disabled = true;
    followButton.textContent = "Finding nearest shuttle…";

    navigator.geolocation.getCurrentPosition(
      pos => {
        followButton.disabled = false;
        followUserLatLng = L.latLng(pos.coords.latitude, pos.coords.longitude);

        // build currentVehicles from markers registry (fast & reliable)
        const currentVehicles = Object.entries(markersByVehicleId).map(([k, e]) => {
          if (!e || !e.lastLatLng || typeof e.lastLatLng.lat !== 'number') return null;
          return { id: String(k), lat: e.lastLatLng.lat, lon: e.lastLatLng.lng };
        }).filter(Boolean);

        // fallback to lastVehicles (API payload) if no markers available
        const sourceVehicles = (currentVehicles.length > 0) ? currentVehicles : (lastVehicles || []);

        const nearestId = findClosestVehicleId(followUserLatLng.lat, followUserLatLng.lng, sourceVehicles);
        if (!nearestId) {
          followButton.disabled = false;
          followButton.textContent = "Follow nearest shuttle";
          alert("No visible shuttles to follow right now.");
          return;
        }

        if (!startFollowing(nearestId)) {
          // If marker not available yet, fallback to centering on coordinates and mark as following
          const fallback = sourceVehicles.find(v => String(v.id) === String(nearestId));
          if (fallback) {
            map.panTo([fallback.lat, fallback.lon], { animate: true });
            followMode = true;
            followedVehicleId = String(nearestId);
            followButton.textContent = "Stop following";
          } else {
            followButton.disabled = false;
            followButton.textContent = "Follow nearest shuttle";
            alert("Unable to follow that shuttle (it may have disappeared).");
          }
        }
      },
      err => {
        followButton.disabled = false;
        followButton.textContent = "Follow nearest shuttle";
        alert("Failed to get your location: " + (err && err.message ? err.message : "permission denied"));
      },
      { enableHighAccuracy: true, timeout: 5000, maximumAge: 10000 }
    );
  });

  // -- application boot sequence --
  loadActiveRoute().then(() => {
    refreshVehicles();
    setInterval(refreshVehicles, VEHICLE_POLL_INTERVAL_MS);
  });
</script>
</body>
</html>
